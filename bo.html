<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Optimization Evolution (Maximization)</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
        :root {
            --color-background: #f5f5f5;
            --color-surface: #ffffff;
            --color-text: #1f2121;
            --color-text-secondary: #626c7c;
            --color-primary: #2180b8;
            --color-primary-hover: #1d744e;
            --color-border: rgba(94, 82, 64, 0.2);
            --color-secondary: rgba(94, 82, 64, 0.12);
            --color-success: #218081;
            --color-error: #c0152f;
            --color-warning: #a84b2f;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--color-background);
            color: var(--color-text);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 28px;
            color: var(--color-text);
        }

        .subtitle {
            color: var(--color-text-secondary);
            margin-bottom: 20px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            background: var(--color-surface);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--color-border);
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        label {
            font-size: 13px;
            font-weight: 500;
            color: var(--color-text);
            white-space: nowrap;
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        input[type="number"] {
            width: 80px;
            padding: 6px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-size: 13px;
        }

        select {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            font-size: 13px;
        }

        input[type="text"] {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            font-size: 13px;
            width: 100%;
        }

        button {
            padding: 8px 16px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 150ms ease;
        }

        button:hover {
            background: var(--color-primary-hover);
        }

        button:active {
            opacity: 0.9;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: var(--color-surface);
            border-radius: 8px;
            border: 1px solid var(--color-border);
            padding: 15px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02);
        }

        .card h2 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .plotly-div {
            width: 100%;
            height: 400px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: var(--color-secondary);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--color-primary);
        }

        .explanation {
            background: var(--color-surface);
            border-radius: 8px;
            border: 1px solid var(--color-border);
            padding: 15px;
            margin-bottom: 20px;
            line-height: 1.5;
            font-size: 13px;
        }

        .explanation strong {
            color: var(--color-primary);
        }

        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                width: 100%;
                justify-content: space-between;
            }

            .control-group input[type="range"] {
                width: 100%;
            }

            .plotly-div {
                height: 320px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”¬ Bayesian Optimization Evolution (Maximization)</h1>
        <p class="subtitle">Gaussian Processes + Expected Improvement selecting high-value regions of f(x)</p>

        <div class="controls">
            <div class="control-group">
                <label for="iteration">Iteration:</label>
                <input type="range" id="iteration" min="1" max="12" value="1">
                <span id="iterDisplay">1/12</span>
            </div>

            <div class="control-group">
                <label for="stepSize">Step Speed:</label>
                <input type="range" id="stepSize" min="500" max="3000" value="1500" step="100">
            </div>

            <button id="playBtn">â–¶ Auto Play</button>
            <button id="resetBtn">â†» Reset</button>

            <div class="control-group">
                <label for="noise">Noise:</label>
                <input type="number" id="noise" min="0" max="0.5" step="0.01" value="0.1">
            </div>

            <div class="control-group" style="flex: 1 1 200px;">
                <label for="funcSelect">Function:</label>
                <select id="funcSelect">
                    <option value="xcx">f(x) = (1/3)Â·xÂ·cos(x)</option>
                    <option value="sinpeak">f(x) = sin(2x) / (1 + 0.3xÂ²)</option>
                    <option value="gaussmix">Two Gaussian peaks</option>
                    <option value="custom">Custom (JS)</option>
                </select>
            </div>

            <div class="control-group" id="customFuncGroup" style="flex: 1 1 100%; display: none;">
                <label for="customFunc">f(x) =</label>
                <input type="text" id="customFunc" placeholder="e.g., Math.sin(x) - 0.1*x*x">
            </div>
        </div>

        <div class="explanation">
            <strong>Maximization view:</strong> The Gaussian Process acts as a surrogate model of the black-box function.
            At each step, the Expected Improvement (EI) acquisition function selects the next point expected to <strong>increase</strong>
            the best value found so far. The blue curve is the GP mean Î¼(x), the shaded region is Â±Ïƒ(x), the dotted line is
            the true f(x), and the EI plot shows where the optimizer wants to sample next.
        </div>

        <div class="grid">
            <div class="card">
                <h2>Function & Gaussian Process</h2>
                <div class="plotly-div" id="mainPlot"></div>
            </div>
            <div class="card">
                <h2>Expected Improvement (EI)</h2>
                <div class="plotly-div" id="eiPlot"></div>
            </div>
        </div>

        <div class="card">
            <h2>Optimization Progress</h2>
            <div class="plotly-div" id="progressPlot"></div>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Best Value</div>
                    <div class="stat-value" id="bestVal">N/A</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Iterations</div>
                    <div class="stat-value" id="iterCount">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Observations</div>
                    <div class="stat-value" id="obsCount">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Improvement</div>
                    <div class="stat-value" id="improvement">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BayesianOptimizer {
            constructor() {
                this.x = [];
                this.y = [];
                this.iteration = 1;
                this.maxIterations = 12;

                this.noiseLevel = 0.1;
                this.kernel_k = 1;
                this.kernel_sigma = 1;
                this.xRange = [-3, 6];

                this.playing = false;
                this.stepSpeed = 1500;

                this.objectiveId = 'xcx';
                this.customFuncStr = '';
                this.customFuncCompiled = null;

                this.initializeOptimization();
            }

            setObjective(id, customStr) {
                this.objectiveId = id;
                this.customFuncStr = customStr || '';
                this.customFuncCompiled = null;

                if (id === 'custom' && this.customFuncStr.trim() !== '') {
                    try {
                        this.customFuncCompiled = new Function('x', 'return ' + this.customFuncStr);
                    } catch (e) {
                        this.customFuncCompiled = null;
                    }
                }
            }

            // true, noise-free function
            trueFunction(x) {
                switch (this.objectiveId) {
                    case 'xcx':
                        return (1 / 3) * x * Math.cos(x);
                    case 'sinpeak':
                        return Math.sin(2 * x) / (1 + 0.3 * x * x);
                    case 'gaussmix':
                        return Math.exp(-0.5 * Math.pow(x - 1, 2)) +
                               0.8 * Math.exp(-0.2 * Math.pow(x - 4, 2));
                    case 'custom':
                        if (this.customFuncCompiled) {
                            try {
                                const v = this.customFuncCompiled(x);
                                return Number.isFinite(v) ? v : 0;
                            } catch (e) {
                                return 0;
                            }
                        }
                        return 0;
                    default:
                        return (1 / 3) * x * Math.cos(x);
                }
            }

            // noisy observations for GP
            objectiveFunction(x) {
                return this.trueFunction(x) +
                    this.noiseLevel * (Math.random() - 0.5) * 2;
            }

            rbfKernel(x1, x2) {
                const dist = Math.pow(x1 - x2, 2);
                return this.kernel_k *
                    Math.exp(-dist / (2 * Math.pow(this.kernel_sigma, 2)));
            }

            buildKernelMatrix(X) {
                const n = X.length;
                const K = Array(n).fill(0).map(() => Array(n).fill(0));
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        K[i][j] = this.rbfKernel(X[i], X[j]);
                    }
                }
                return K;
            }

            invertMatrix(M) {
                const n = M.length;
                if (n === 1) return [[1 / M[0][0]]];

                const A = M.map(row => [...row]);
                const I = Array(n).fill(0).map((_, i) =>
                    Array(n).fill(0).map((_, j) => (i === j ? 1 : 0))
                );

                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
                    }
                    [A[i], A[maxRow]] = [A[maxRow], A[i]];
                    [I[i], I[maxRow]] = [I[maxRow], I[i]];

                    for (let k = i + 1; k < n; k++) {
                        const c = A[k][i] / A[i][i];
                        for (let j = i; j < n; j++) A[k][j] -= c * A[i][j];
                        for (let j = 0; j < n; j++) I[k][j] -= c * I[i][j];
                    }
                }

                for (let i = n - 1; i >= 0; i--) {
                    for (let k = i - 1; k >= 0; k--) {
                        const c = A[k][i] / A[i][i];
                        for (let j = 0; j < n; j++) A[k][j] -= c * A[i][j];
                        for (let j = 0; j < n; j++) I[k][j] -= c * I[i][j];
                    }
                    const c = 1 / A[i][i];
                    for (let j = 0; j < n; j++) {
                        A[i][j] *= c;
                        I[i][j] *= c;
                    }
                }
                return I;
            }

            // GP posterior with observation noise included
            predictGP(xTest) {
                if (this.x.length === 0) {
                    return { mean: 0, variance: this.kernel_k };
                }

                const K_XX = this.buildKernelMatrix(this.x);
                const n = this.x.length;
                const noiseVar = Math.pow(this.noiseLevel, 2) + 1e-6;
                for (let i = 0; i < n; i++) {
                    K_XX[i][i] += noiseVar;
                }

                const K_inv = this.invertMatrix(K_XX);

                const k_x = this.x.map(xi => this.rbfKernel(xTest, xi));
                const k_xx = this.rbfKernel(xTest, xTest);

                let mean = 0;
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        sum += K_inv[i][j] * this.y[j];
                    }
                    mean += k_x[i] * sum;
                }

                let variance = k_xx;
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        sum += K_inv[i][j] * k_x[j];
                    }
                    variance -= k_x[i] * sum;
                }

                return { mean, variance: Math.max(0, variance) };
            }

            // Expected Improvement (maximization)
            computeEI(xTest) {
                const { mean, variance } = this.predictGP(xTest);
                const sigma = Math.sqrt(variance);

                if (this.y.length === 0) return 0;

                const fStar = Math.max(...this.y);
                const improvement = mean - fStar;

                if (sigma < 1e-6) return 0;

                const Z = improvement / sigma;
                const phi = (1 / Math.sqrt(2 * Math.PI)) *
                            Math.exp(-0.5 * Z * Z);
                const Phi = 0.5 * (1 + this.erf(Z / Math.sqrt(2)));

                return improvement * Phi + sigma * phi;
            }

            erf(x) {
                const a1 = 0.254829592;
                const a2 = -0.284496736;
                const a3 = 1.421413741;
                const a4 = -1.453152027;
                const a5 = 1.061405429;
                const p = 0.3275911;

                const sign = x < 0 ? -1 : 1;
                x = Math.abs(x);
                const t = 1.0 / (1.0 + p * x);
                const y = 1.0 - (((((a5 * t + a4) * t + a3) * t + a2) * t +
                                  a1) * t) * Math.exp(-x * x);
                return sign * y;
            }

            initializeOptimization() {
                this.x = [];
                this.y = [];
                this.iteration = 1;
                this.addObservation();
            }

            addObservation() {
                if (this.iteration === 1) {
                    this.x.push(2);
                } else {
                    const xTest = this.linspace(this.xRange[0], this.xRange[1], 200);
                    let bestX = xTest[0];
                    let bestEI = this.computeEI(xTest[0]);

                    for (let i = 1; i < xTest.length; i++) {
                        const ei = this.computeEI(xTest[i]);
                        if (ei > bestEI) {
                            bestEI = ei;
                            bestX = xTest[i];
                        }
                    }
                    this.x.push(bestX);
                }

                const lastX = this.x[this.x.length - 1];
                this.y.push(this.objectiveFunction(lastX));
            }

            linspace(a, b, n) {
                const arr = [];
                for (let i = 0; i < n; i++) {
                    arr.push(a + (b - a) * i / (n - 1));
                }
                return arr;
            }

            getPlotData() {
                const xTest = this.linspace(this.xRange[0], this.xRange[1], 200);
                const means = [];
                const sigmas = [];

                for (let x of xTest) {
                    const { mean, variance } = this.predictGP(x);
                    means.push(mean);
                    sigmas.push(Math.sqrt(variance));
                }

                const eis = xTest.map(x => this.computeEI(x));

                return { xTest, means, sigmas, eis };
            }

            nextIteration() {
                if (this.iteration < this.maxIterations) {
                    this.iteration++;
                    this.addObservation();
                    return true;
                }
                return false;
            }

            reset(newNoise) {
                this.noiseLevel = newNoise;
                this.initializeOptimization();
            }
        }

        const optimizer = new BayesianOptimizer();

        const iterSlider = document.getElementById('iteration');
        const playBtn = document.getElementById('playBtn');
        const resetBtn = document.getElementById('resetBtn');
        const noiseInput = document.getElementById('noise');
        const stepSizeSlider = document.getElementById('stepSize');
        const funcSelect = document.getElementById('funcSelect');
        const customFuncGroup = document.getElementById('customFuncGroup');
        const customFuncInput = document.getElementById('customFunc');

        let autoPlayInterval = null;

        function updateDisplay() {
            const { xTest, means, sigmas, eis } = optimizer.getPlotData();

            const trueY = xTest.map(x => optimizer.trueFunction(x));

            const mainTrace1 = {
                x: xTest,
                y: means,
                name: 'Mean Î¼(x)',
                mode: 'lines',
                line: { color: 'rgb(33, 128, 141)', width: 3 }
            };

            const upperBound = means.map((m, i) => m + sigmas[i]);
            const lowerBound = means.map((m, i) => m - sigmas[i]);

            const mainTrace2 = {
                x: [...xTest, ...xTest.reverse()],
                y: [...upperBound, ...lowerBound.reverse()],
                fill: 'toself',
                fillcolor: 'rgba(33, 128, 141, 0.2)',
                line: { color: 'rgba(255, 255, 255, 0)' },
                name: 'Â±Ïƒ(x)',
                hoverinfo: 'skip'
            };

            const mainTrace3 = {
                x: optimizer.x,
                y: optimizer.y,
                mode: 'markers',
                marker: { size: 8, color: 'rgb(255, 84, 89)', symbol: 'diamond' },
                name: 'Observed Points',
                hovertemplate: 'x: %{x:.2f}<br>y: %{y:.2f}'
            };

            const mainTrace4 = {
                x: xTest,
                y: trueY,
                mode: 'lines',
                line: { color: 'rgba(0, 0, 0, 0.3)', width: 2, dash: 'dot' },
                name: 'True f(x)'
            };

            const tracesMain = [mainTrace4, mainTrace2, mainTrace1, mainTrace3];

            if (optimizer.x.length > 0) {
                const lastX = optimizer.x[optimizer.x.length - 1];
                const lastY = optimizer.y[optimizer.y.length - 1];

                const latestTrace = {
                    x: [lastX],
                    y: [lastY],
                    mode: 'markers',
                    marker: { size: 10, color: 'rgb(34, 197, 94)', symbol: 'star' },
                    name: 'Latest Query',
                    hovertemplate: 'Latest: (%{x:.2f}, %{y:.2f})'
                };
                tracesMain.push(latestTrace);
            }

            Plotly.newPlot('mainPlot', tracesMain, {
                title: `Iteration ${optimizer.iteration}`,
                xaxis: { title: 'x' },
                yaxis: { title: 'f(x)' },
                hovermode: 'closest',
                showlegend: true,
                height: 400
            }, { responsive: true });

            const eiTrace = {
                x: xTest,
                y: eis,
                mode: 'lines',
                fill: 'tozeroy',
                line: { color: 'rgb(230, 129, 97)', width: 2 },
                fillcolor: 'rgba(230, 129, 97, 0.3)',
                name: 'EI(x)'
            };

            const eiTraces = [eiTrace];

            if (
                optimizer.iteration < optimizer.maxIterations &&
                eis.length > 0 &&
                Math.max(...eis) > 0
            ) {
                const maxEiIdx = eis.indexOf(Math.max(...eis));
                const nextPoint = {
                    x: [xTest[maxEiIdx]],
                    y: [eis[maxEiIdx]],
                    mode: 'markers',
                    marker: { size: 10, color: 'rgb(34, 197, 94)', symbol: 'star' },
                    name: 'Next Query Point'
                };
                eiTraces.push(nextPoint);
            }

            Plotly.newPlot('eiPlot', eiTraces, {
                title: 'Expected Improvement Acquisition Function (Maximization)',
                xaxis: { title: 'x' },
                yaxis: { title: 'EI(x)' },
                hovermode: 'closest',
                showlegend: true,
                height: 400
            }, { responsive: true });

            const iterationsArray = Array.from(
                { length: optimizer.y.length },
                (_, i) => i + 1
            );

            const progressTrace = {
                x: iterationsArray,
                y: optimizer.y,
                mode: 'lines+markers',
                line: { color: 'rgb(33, 128, 141)', width: 2 },
                marker: { size: 6 },
                fill: 'tozeroy',
                fillcolor: 'rgba(33, 128, 141, 0.1)',
                name: 'Observed Values'
            };

            let bestTrajectory = [];
            let currentBest = -Infinity;
            for (let i = 0; i < optimizer.y.length; i++) {
                currentBest = Math.max(currentBest, optimizer.y[i]);
                bestTrajectory.push(currentBest);
            }

            const bestTrace = {
                x: iterationsArray,
                y: bestTrajectory,
                mode: 'lines',
                line: { color: 'rgb(192, 21, 47)', width: 2, dash: 'dash' },
                name: 'Best Found (so far)'
            };

            Plotly.newPlot('progressPlot', [progressTrace, bestTrace], {
                title: 'Optimization Progress (Maximization)',
                xaxis: { title: 'Iteration' },
                yaxis: { title: 'Function Value' },
                hovermode: 'closest',
                height: 300
            }, { responsive: true });

            const bestSoFar = optimizer.y.length > 0 ? Math.max(...optimizer.y) : NaN;

            document.getElementById('iterDisplay').textContent =
                `${optimizer.iteration}/${optimizer.maxIterations}`;
            document.getElementById('iterCount').textContent = optimizer.iteration;
            document.getElementById('obsCount').textContent = optimizer.x.length;
            document.getElementById('bestVal').textContent =
                isNaN(bestSoFar) ? 'N/A' : bestSoFar.toFixed(3);

            if (optimizer.y.length > 1) {
                const initialVal = optimizer.y[0];
                const improvement = ((bestSoFar - initialVal) / Math.abs(initialVal || 1)) * 100;
                document.getElementById('improvement').textContent =
                    improvement.toFixed(1) + '%';
            } else {
                document.getElementById('improvement').textContent = '0%';
            }
        }

        function startAutoPlay() {
            optimizer.playing = true;
            playBtn.textContent = 'â¸ Stop';
            clearInterval(autoPlayInterval);

            autoPlayInterval = setInterval(() => {
                if (!optimizer.nextIteration()) {
                    clearInterval(autoPlayInterval);
                    optimizer.playing = false;
                    playBtn.textContent = 'â–¶ Auto Play';
                    return;
                }
                iterSlider.value = optimizer.iteration;
                updateDisplay();
            }, optimizer.stepSpeed);
        }

        iterSlider.addEventListener('change', () => {
            const targetIter = parseInt(iterSlider.value, 10);
            optimizer.x = [];
            optimizer.y = [];
            optimizer.iteration = 1;
            optimizer.addObservation();

            while (optimizer.iteration < targetIter) {
                optimizer.iteration++;
                optimizer.addObservation();
            }

            updateDisplay();
        });

        playBtn.addEventListener('click', () => {
            if (!optimizer.playing) {
                startAutoPlay();
            } else {
                optimizer.playing = false;
                clearInterval(autoPlayInterval);
                playBtn.textContent = 'â–¶ Auto Play';
            }
        });

        resetBtn.addEventListener('click', () => {
            optimizer.playing = false;
            clearInterval(autoPlayInterval);
            optimizer.reset(parseFloat(noiseInput.value));
            iterSlider.value = 1;
            playBtn.textContent = 'â–¶ Auto Play';
            updateDisplay();
        });

        noiseInput.addEventListener('change', () => {
            optimizer.playing = false;
            clearInterval(autoPlayInterval);
            optimizer.reset(parseFloat(noiseInput.value));
            iterSlider.value = 1;
            playBtn.textContent = 'â–¶ Auto Play';
            updateDisplay();
        });

        stepSizeSlider.addEventListener('change', () => {
            optimizer.stepSpeed = parseInt(stepSizeSlider.value, 10);
            if (optimizer.playing) {
                startAutoPlay();
            }
        });

        funcSelect.addEventListener('change', () => {
            const id = funcSelect.value;
            customFuncGroup.style.display = id === 'custom' ? 'flex' : 'none';

            optimizer.playing = false;
            clearInterval(autoPlayInterval);
            playBtn.textContent = 'â–¶ Auto Play';

            const customStr = id === 'custom' ? customFuncInput.value : '';
            optimizer.setObjective(id, customStr);
            optimizer.reset(parseFloat(noiseInput.value));
            iterSlider.value = 1;
            updateDisplay();
        });

        customFuncInput.addEventListener('change', () => {
            if (funcSelect.value !== 'custom') return;

            optimizer.playing = false;
            clearInterval(autoPlayInterval);
            playBtn.textContent = 'â–¶ Auto Play';

            optimizer.setObjective('custom', customFuncInput.value);
            optimizer.reset(parseFloat(noiseInput.value));
            iterSlider.value = 1;
            updateDisplay();
        });

        updateDisplay();
    </script>
</body>
</html>
