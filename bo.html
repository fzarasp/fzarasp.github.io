<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Optimization Evolution</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
        :root {
            --color-background: #f5f5f5;
            --color-surface: #ffffff;
            --color-text: #1f2121;
            --color-text-secondary: #626c7c;
            --color-primary: #2180b8;
            --color-primary-hover: #1d744e;
            --color-border: rgba(94, 82, 64, 0.2);
            --color-secondary: rgba(94, 82, 64, 0.12);
            --color-success: #218081;
            --color-error: #c0152f;
            --color-warning: #a84b2f;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--color-background);
            color: var(--color-text);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 28px;
            color: var(--color-text);
        }

        .subtitle {
            color: var(--color-text-secondary);
            margin-bottom: 20px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            background: var(--color-surface);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--color-border);
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-size: 13px;
            font-weight: 500;
            color: var(--color-text);
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        input[type="number"] {
            width: 80px;
            padding: 6px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-size: 13px;
        }

        button {
            padding: 8px 16px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 150ms ease;
        }

        button:hover {
            background: var(--color-primary-hover);
        }

        button:active {
            opacity: 0.9;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: var(--color-surface);
            border-radius: 8px;
            border: 1px solid var(--color-border);
            padding: 15px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02);
        }

        .card h2 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .plotly-div {
            width: 100%;
            height: 400px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: var(--color-secondary);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--color-primary);
        }

        .explanation {
            background: var(--color-surface);
            border-radius: 8px;
            border: 1px solid var(--color-border);
            padding: 15px;
            margin-bottom: 20px;
            line-height: 1.5;
            font-size: 13px;
        }

        .explanation strong {
            color: var(--color-primary);
        }

        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”¬ Bayesian Optimization Evolution</h1>
        <p class="subtitle">Visualizing how Gaussian Processes and Expected Improvement guide exploration</p>

        <div class="controls">
            <div class="control-group">
                <label for="iteration">Iteration:</label>
                <input type="range" id="iteration" min="1" max="12" value="1">
                <span id="iterDisplay">1/12</span>
            </div>
            <div class="control-group">
                <label for="stepSize">Step Speed:</label>
                <input type="range" id="stepSize" min="500" max="3000" value="1500" step="100">
            </div>
            <button id="playBtn">â–¶ Auto Play</button>
            <button id="resetBtn">â†» Reset</button>
            <div class="control-group" style="margin-left: auto;">
                <label for="noise">Noise Level:</label>
                <input type="number" id="noise" min="0" max="0.5" step="0.01" value="0.1">
            </div>
        </div>

        <div class="explanation">
            <strong>How it works:</strong> Bayesian Optimization uses a Gaussian Process as a <strong>surrogate model</strong> to approximate the expensive black-box function. At each iteration, it evaluates the <strong>Expected Improvement (EI)</strong> acquisition function to select the most promising next point. The blue curve represents the mean prediction Î¼(x), the shaded area shows Â±Ïƒ(x) confidence intervals, and the lower plots show the EI acquisition function guiding where to query next.
        </div>

        <div class="grid">
            <div class="card">
                <h2>Function & Gaussian Process</h2>
                <div class="plotly-div" id="mainPlot"></div>
            </div>
            <div class="card">
                <h2>Expected Improvement (EI)</h2>
                <div class="plotly-div" id="eiPlot"></div>
            </div>
        </div>

        <div class="card">
            <h2>Optimization Progress</h2>
            <div class="plotly-div" id="progressPlot"></div>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Best Value</div>
                    <div class="stat-value" id="bestVal">N/A</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Iterations</div>
                    <div class="stat-value" id="iterCount">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Observations</div>
                    <div class="stat-value" id="obsCount">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Improvement</div>
                    <div class="stat-value" id="improvement">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BayesianOptimizer {
            constructor() {
                this.x = [];
                this.y = [];
                this.iteration = 1;
                this.maxIterations = 12;
                this.noiseLevel = 0.1;
                this.kernel_k = 1;
                this.kernel_sigma = 1;
                this.xRange = [-3, 6];
                this.playing = false;
                this.stepSpeed = 1500;

                this.initializeOptimization();
            }

            // Objective function: f(x) = (1/3) * x * cos(x)
            objectiveFunction(x) {
                return (1 / 3) * x * Math.cos(x) + this.noiseLevel * (Math.random() - 0.5) * 2;
            }

            // RBF Kernel
            rbfKernel(x1, x2) {
                const dist = Math.pow(x1 - x2, 2);
                return this.kernel_k * Math.exp(-dist / (2 * Math.pow(this.kernel_sigma, 2)));
            }

            // Build kernel matrix
            buildKernelMatrix(X) {
                const n = X.length;
                const K = Array(n).fill(0).map(() => Array(n).fill(0));
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        K[i][j] = this.rbfKernel(X[i], X[j]);
                    }
                }
                return K;
            }

            // Simple matrix inversion (2x2 for small matrices, Gauss elimination for larger)
            invertMatrix(M) {
                const n = M.length;
                if (n === 1) return [[1 / M[0][0]]];
                
                const A = M.map(row => [...row]);
                const I = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) => i === j ? 1 : 0));

                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
                    }
                    [A[i], A[maxRow]] = [A[maxRow], A[i]];
                    [I[i], I[maxRow]] = [I[maxRow], I[i]];

                    for (let k = i + 1; k < n; k++) {
                        const c = A[k][i] / A[i][i];
                        for (let j = i; j < n; j++) A[k][j] -= c * A[i][j];
                        for (let j = 0; j < n; j++) I[k][j] -= c * I[i][j];
                    }
                }

                for (let i = n - 1; i >= 0; i--) {
                    for (let k = i - 1; k >= 0; k--) {
                        const c = A[k][i] / A[i][i];
                        for (let j = 0; j < n; j++) A[k][j] -= c * A[i][j];
                        for (let j = 0; j < n; j++) I[k][j] -= c * I[i][j];
                    }
                    const c = 1 / A[i][i];
                    for (let j = 0; j < n; j++) {
                        A[i][j] *= c;
                        I[i][j] *= c;
                    }
                }
                return I;
            }

            // GP Posterior prediction
            predictGP(xTest) {
                if (this.x.length === 0) {
                    return { mean: 0, variance: this.kernel_k };
                }

                const K_XX = this.buildKernelMatrix(this.x);
                const K_inv = this.invertMatrix(K_XX);

                const k_x = this.x.map(xi => this.rbfKernel(xTest, xi));
                const k_xx = this.rbfKernel(xTest, xTest);

                let mean = 0;
                for (let i = 0; i < this.x.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < this.x.length; j++) {
                        sum += K_inv[i][j] * this.y[j];
                    }
                    mean += k_x[i] * sum;
                }

                let variance = k_xx;
                for (let i = 0; i < this.x.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < this.x.length; j++) {
                        sum += K_inv[i][j] * k_x[j];
                    }
                    variance -= k_x[i] * sum;
                }

                return { mean, variance: Math.max(0, variance) };
            }

            // Expected Improvement
            computeEI(xTest) {
                const { mean, variance } = this.predictGP(xTest);
                const sigma = Math.sqrt(variance);

                if (this.y.length === 0) return 0;

                const fStar = Math.min(...this.y);
                const improvement = fStar - mean;

                if (sigma < 1e-6) return 0;

                const Z = improvement / sigma;
                const phi = (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * Z * Z);
                const Phi = 0.5 * (1 + this.erf(Z / Math.sqrt(2)));

                return improvement * Phi + sigma * phi;
            }

            erf(x) {
                const a1 = 0.254829592;
                const a2 = -0.284496736;
                const a3 = 1.421413741;
                const a4 = -1.453152027;
                const a5 = 1.061405429;
                const p = 0.3275911;

                const sign = x < 0 ? -1 : 1;
                x = Math.abs(x);
                const t = 1.0 / (1.0 + p * x);
                const y = 1.0 - (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t) * Math.exp(-x * x);
                return sign * y;
            }

            initializeOptimization() {
                this.x = [];
                this.y = [];
                this.iteration = 1;
                this.addObservation();
            }

            addObservation() {
                if (this.iteration === 1) {
                    this.x.push(2);
                } else {
                    const xTest = this.linspace(this.xRange[0], this.xRange[1], 200);
                    let bestX = xTest[0];
                    let bestEI = this.computeEI(xTest[0]);

                    for (let i = 1; i < xTest.length; i++) {
                        const ei = this.computeEI(xTest[i]);
                        if (ei > bestEI) {
                            bestEI = ei;
                            bestX = xTest[i];
                        }
                    }
                    this.x.push(bestX);
                }

                this.y.push(this.objectiveFunction(this.x[this.x.length - 1]));
            }

            linspace(a, b, n) {
                const arr = [];
                for (let i = 0; i < n; i++) {
                    arr.push(a + (b - a) * i / (n - 1));
                }
                return arr;
            }

            getPlotData() {
                const xTest = this.linspace(this.xRange[0], this.xRange[1], 200);
                const means = [];
                const sigmas = [];

                for (let x of xTest) {
                    const { mean, variance } = this.predictGP(x);
                    means.push(mean);
                    sigmas.push(Math.sqrt(variance));
                }

                const eis = xTest.map(x => this.computeEI(x));

                return { xTest, means, sigmas, eis };
            }

            nextIteration() {
                if (this.iteration < this.maxIterations) {
                    this.iteration++;
                    this.addObservation();
                    return true;
                }
                return false;
            }

            reset(newNoise) {
                this.noiseLevel = newNoise;
                this.initializeOptimization();
            }
        }

        const optimizer = new BayesianOptimizer();
        const iterSlider = document.getElementById('iteration');
        const playBtn = document.getElementById('playBtn');
        const resetBtn = document.getElementById('resetBtn');
        const noiseInput = document.getElementById('noise');
        const stepSizeSlider = document.getElementById('stepSize');

        let autoPlayInterval = null;

        function updateDisplay() {
            const { xTest, means, sigmas, eis } = optimizer.getPlotData();

            // Main GP plot
            const trueY = xTest.map(x => (1/3) * x * Math.cos(x));
            
            const mainTrace1 = {
                x: xTest,
                y: means,
                name: 'Mean Î¼(x)',
                mode: 'lines',
                line: { color: 'rgb(33, 128, 141)', width: 3 },
            };

            const upperBound = means.map((m, i) => m + sigmas[i]);
            const lowerBound = means.map((m, i) => m - sigmas[i]);

            const mainTrace2 = {
                x: [...xTest, ...xTest.reverse()],
                y: [...upperBound, ...lowerBound.reverse()],
                fill: 'toself',
                fillcolor: 'rgba(33, 128, 141, 0.2)',
                line: { color: 'rgba(255, 255, 255, 0)' },
                name: 'Â±Ïƒ(x)',
                hoverinfo: 'skip'
            };

            const mainTrace3 = {
                x: optimizer.x,
                y: optimizer.y,
                mode: 'markers',
                marker: { size: 8, color: 'rgb(255, 84, 89)', symbol: 'diamond' },
                name: 'Observed Points',
                hovertemplate: 'x: %{x:.2f}<br>y: %{y:.2f}'
            };

            const mainTrace4 = {
                x: xTest,
                y: trueY,
                mode: 'lines',
                line: { color: 'rgba(0, 0, 0, 0.3)', width: 2, dash: 'dot' },
                name: 'True f(x)',
            };

            if (optimizer.x.length > 0) {
                const lastX = optimizer.x[optimizer.x.length - 1];
                const lastY = optimizer.y[optimizer.y.length - 1];
                mainTrace3.x = [...mainTrace3.x.slice(0, -1), lastX];
                mainTrace3.y = [...mainTrace3.y.slice(0, -1), lastY];
                
                const newTrace = {
                    x: [lastX],
                    y: [lastY],
                    mode: 'markers',
                    marker: { size: 10, color: 'rgb(34, 197, 94)', symbol: 'star' },
                    name: 'Latest Query',
                    hovertemplate: 'Latest: (%{x:.2f}, %{y:.2f})'
                };
                
                Plotly.newPlot('mainPlot', [mainTrace4, mainTrace2, mainTrace1, mainTrace3, newTrace], {
                    title: `Iteration ${optimizer.iteration}`,
                    xaxis: { title: 'x' },
                    yaxis: { title: 'f(x)' },
                    hovermode: 'closest',
                    showlegend: true,
                    height: 400
                }, { responsive: true });
            } else {
                Plotly.newPlot('mainPlot', [mainTrace4, mainTrace2, mainTrace1, mainTrace3], {
                    title: `Iteration ${optimizer.iteration}`,
                    xaxis: { title: 'x' },
                    yaxis: { title: 'f(x)' },
                    hovermode: 'closest',
                    showlegend: true,
                    height: 400
                }, { responsive: true });
            }

            // EI plot
            const eiTrace = {
                x: xTest,
                y: eis,
                mode: 'lines',
                fill: 'tozeroy',
                line: { color: 'rgb(230, 129, 97)', width: 2 },
                fillcolor: 'rgba(230, 129, 97, 0.3)',
                name: 'EI(x)'
            };

            let eiTraces = [eiTrace];
            if (eis.length > 0 && Math.max(...eis) > 0) {
                const maxEiIdx = eis.indexOf(Math.max(...eis));
                const nextPoint = {
                    x: [xTest[maxEiIdx]],
                    y: [eis[maxEiIdx]],
                    mode: 'markers',
                    marker: { size: 10, color: 'rgb(34, 197, 94)', symbol: 'star' },
                    name: 'Next Query Point'
                };
                eiTraces.push(nextPoint);
            }

            Plotly.newPlot('eiPlot', eiTraces, {
                title: 'Expected Improvement Acquisition Function',
                xaxis: { title: 'x' },
                yaxis: { title: 'EI(x)' },
                hovermode: 'closest',
                showlegend: true,
                height: 400
            }, { responsive: true });

            // Progress plot
            const progressTrace = {
                x: Array.from({length: optimizer.iteration}, (_, i) => i + 1),
                y: optimizer.y,
                mode: 'lines+markers',
                line: { color: 'rgb(33, 128, 141)', width: 2 },
                marker: { size: 6 },
                fill: 'tozeroy',
                fillcolor: 'rgba(33, 128, 141, 0.1)',
                name: 'Observed Values'
            };

            const bestSoFar = optimizer.y.length > 0 ? Math.min(...optimizer.y) : 0;
            const bestTrace = {
                x: Array.from({length: optimizer.iteration}, (_, i) => i + 1),
                y: Array(optimizer.iteration).fill(bestSoFar),
                mode: 'lines',
                line: { color: 'rgb(192, 21, 47)', width: 2, dash: 'dash' },
                name: 'Best Found'
            };

            Plotly.newPlot('progressPlot', [progressTrace, bestTrace], {
                title: 'Optimization Progress',
                xaxis: { title: 'Iteration' },
                yaxis: { title: 'Function Value' },
                hovermode: 'closest',
                height: 300
            }, { responsive: true });

            // Update stats
            document.getElementById('iterDisplay').textContent = `${optimizer.iteration}/${optimizer.maxIterations}`;
            document.getElementById('iterCount').textContent = optimizer.iteration;
            document.getElementById('obsCount').textContent = optimizer.x.length;
            document.getElementById('bestVal').textContent = bestSoFar.toFixed(3);
            
            if (optimizer.iteration > 1) {
                const initialVal = optimizer.y[0];
                const improvement = ((initialVal - bestSoFar) / Math.abs(initialVal)) * 100;
                document.getElementById('improvement').textContent = improvement.toFixed(1) + '%';
            }
        }

        iterSlider.addEventListener('change', () => {
            optimizer.iteration = parseInt(iterSlider.value);
            optimizer.x = [];
            optimizer.y = [];
            for (let i = 0; i < optimizer.iteration; i++) {
                optimizer.addObservation();
            }
            updateDisplay();
        });

        playBtn.addEventListener('click', () => {
            if (!optimizer.playing) {
                optimizer.playing = true;
                playBtn.textContent = 'â¸ Stop';
                autoPlayInterval = setInterval(() => {
                    if (!optimizer.nextIteration()) {
                        clearInterval(autoPlayInterval);
                        optimizer.playing = false;
                        playBtn.textContent = 'â–¶ Auto Play';
                    }
                    iterSlider.value = optimizer.iteration;
                    updateDisplay();
                }, optimizer.stepSpeed);
            } else {
                optimizer.playing = false;
                clearInterval(autoPlayInterval);
                playBtn.textContent = 'â–¶ Auto Play';
            }
        });

        resetBtn.addEventListener('click', () => {
            optimizer.playing = false;
            clearInterval(autoPlayInterval);
            optimizer.reset(parseFloat(noiseInput.value));
            iterSlider.value = 1;
            playBtn.textContent = 'â–¶ Auto Play';
            updateDisplay();
        });

        noiseInput.addEventListener('change', () => {
            optimizer.reset(parseFloat(noiseInput.value));
            iterSlider.value = 1;
            updateDisplay();
        });

        stepSizeSlider.addEventListener('change', () => {
            optimizer.stepSpeed = parseInt(stepSizeSlider.value);
        });

        updateDisplay();
    </script>
</body>
</html>
